#ifndef EXP_RS_H
#define EXP_RS_H

#pragma once

/* Warning: This file is autogenerated by cbindgen. Do not modify manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>


#define EXP_RS_MAX_VARIABLES 16

#define EXP_RS_MAX_CONSTANTS 8

#define EXP_RS_MAX_ARRAYS 4

#define EXP_RS_MAX_ATTRIBUTES 4

#define EXP_RS_MAX_NESTED_ARRAYS 2

#define EXP_RS_MAX_AST_CACHE 16

#define EXP_RS_MAX_NATIVE_FUNCTIONS 64

#define EXP_RS_MAX_EXPRESSION_FUNCTIONS 8

#define EXP_RS_MAX_USER_FUNCTIONS 4

#define EXP_RS_MAX_ATTR_KEYS 4

#define EXP_RS_MAX_KEY_LENGTH 32

#define EXP_RS_MAX_FUNCTION_NAME_LENGTH 32

#if defined(USE_F32)
/**
 * Define the floating-point type based on feature flags
 */
typedef float Real;
#endif

#if !defined(USE_F32)
typedef double Real;
#endif

/**
 * Result structure returned by evaluation functions.
 *
 * This structure returns either a successful result value or an error message.
 * When status is 0, the value field contains the result of the expression evaluation.
 * When status is non-zero, the error field contains a null-terminated string with
 * the error message, which must be freed using exp_rs_free_error.
 */
typedef struct EvalResult {
  /**
   * Status code: 0 for success, non-zero for errors
   */
  int32_t status;
  /**
   * The result value (valid when status is 0)
   */
  Real value;
  /**
   * Error message (valid when status is non-zero, must be freed by caller)
   */
  const char *error;
} EvalResult;

/**
 * Opaque handle to an evaluation context for C code.
 *
 * This is an opaque type that C code can use to reference an EvalContext.
 * C code should only store and pass this pointer, never dereferencing it directly.
 */
typedef struct EvalContextOpaque {
  uint8_t _private[0];
} EvalContextOpaque;

/**
 * Status information for individual batch evaluation results.
 *
 * This structure tracks the outcome of each expression evaluation in a batch,
 * allowing detailed error reporting when processing multiple expressions.
 */
typedef struct BatchStatus {
  /**
   * Error code: 0 = success, non-zero = error
   */
  int32_t code;
  /**
   * Index of the expression that produced this result (0-based)
   */
  uintptr_t expr_index;
  /**
   * Index of the batch item that produced this result (0-based)
   */
  uintptr_t batch_index;
} BatchStatus;

/**
 * Request structure for batch evaluation of multiple expressions.
 *
 * This structure allows efficient evaluation of multiple expressions with
 * different parameter values, reusing parsed ASTs and evaluation engines
 * for significant performance improvements.
 *
 * # Memory Layout
 *
 * - `expressions`: Array of C strings containing the expressions to evaluate
 * - `param_values`: 2D array where param_values[i] points to an array of values for parameter i
 * - `results`: 2D array where results[i] points to an array to store results for expression i
 *
 * # Memory Ownership
 *
 * The caller owns all memory passed to this structure and is responsible for:
 * - Keeping all pointers valid for the duration of the evaluation
 * - Freeing the memory after the evaluation completes
 * - Pre-allocating result arrays unless using exp_rs_batch_eval_alloc
 *
 * For embedded systems, consider pre-allocating all arrays at startup to avoid
 * runtime allocations. See test_embedded_pool.c for an example.
 *
 * # Example
 *
 * ```c
 * // Evaluate 3 expressions with 2 parameters over 1000 data points
 * const char* exprs[] = {"a + b", "a * sin(b)", "sqrt(a*a + b*b)"};
 * const char* params[] = {"a", "b"};
 * Real a_values[1000] = {...};
 * Real b_values[1000] = {...};
 * Real* param_vals[] = {a_values, b_values};
 * Real results1[1000], results2[1000], results3[1000];
 * Real* results[] = {results1, results2, results3};
 *
 * BatchEvalRequest req = {
 *     .expressions = exprs,
 *     .expression_count = 3,
 *     .param_names = params,
 *     .param_count = 2,
 *     .param_values = param_vals,
 *     .batch_size = 1000,
 *     .results = results,
 *     .allocate_results = false,
 *     .stop_on_error = false,
 *     .statuses = NULL
 * };
 *
 * int status = exp_rs_batch_eval(&req, ctx);
 * ```
 */
typedef struct BatchEvalRequest {
  /**
   * Array of expression strings to evaluate
   */
  const char *const *expressions;
  /**
   * Number of expressions in the array
   */
  uintptr_t expression_count;
  /**
   * Array of parameter names (shared across all evaluations)
   */
  const char *const *param_names;
  /**
   * Number of parameters
   */
  uintptr_t param_count;
  /**
   * 2D array of parameter values: param_values[param_idx][batch_idx]
   */
  const Real *const *param_values;
  /**
   * Number of items in each parameter array (batch size)
   */
  uintptr_t batch_size;
  /**
   * 2D array for results: results[expr_idx][batch_idx]
   * Must point to pre-allocated buffers
   */
  Real **results;
  /**
   * If true, stop evaluation on first error
   */
  bool stop_on_error;
  /**
   * Optional array for detailed error tracking
   * Size should be expression_count * batch_size
   * Can be NULL if detailed error tracking is not needed
   */
  struct BatchStatus *statuses;
} BatchEvalRequest;

/**
 * Result structure for batch evaluation when using library allocation.
 *
 * This structure is returned when the library allocates the result arrays,
 * providing both the results and allocation metadata.
 */
typedef struct BatchEvalResult {
  /**
   * Allocated 2D result array: results[expr_idx][batch_idx]
   */
  Real **results;
  /**
   * Number of expressions (rows in results)
   */
  uintptr_t expression_count;
  /**
   * Number of batch items (columns in results)
   */
  uintptr_t batch_size;
  /**
   * Overall status: 0 = success, non-zero = error
   */
  int32_t status;
} BatchEvalResult;

/**
 * Opaque type for BatchBuilder
 */
typedef struct BatchBuilderOpaque {
  uint8_t _data[0];
} BatchBuilderOpaque;

#if defined(USE_F32)
#define TEST_PRECISION 1e-6
#endif

#if !defined(USE_F32)
#define TEST_PRECISION 1e-10
#endif

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

extern int32_t *EXP_RS_PANIC_FLAG;

extern const void *EXP_RS_LOG_FUNCTION;

__attribute__((aligned(8)))
void exp_rs_register_panic_handler(int32_t *flag_ptr,
                                   const void *log_func);

/**
 * Frees a string allocated by exp_rs FFI functions.
 *
 * This function should be called to free the error message string in an EvalResult
 * when status is non-zero. Not calling this function will result in a memory leak.
 *
 * # Parameters
 *
 * * `ptr` - Pointer to the string to free. Must be a pointer returned in an EvalResult error field.
 *
 * # Safety
 *
 * This function is unsafe because it dereferences a raw pointer. The caller must ensure that:
 * 1. The pointer is valid and was allocated by one of the exp_rs FFI functions
 * 2. The pointer is not used after calling this function
 * 3. The pointer is not freed more than once
 */
__attribute__((aligned(8))) void exp_rs_free_error(char *ptr);

/**
 * Evaluates a mathematical expression without a context.
 *
 * This function evaluates a mathematical expression string and returns the result.
 * Without a context, only built-in functions and constants are available.
 *
 * # Parameters
 *
 * * `expr` - Null-terminated string containing the expression to evaluate
 *
 * # Returns
 *
 * An EvalResult structure containing either the result value or an error message.
 *
 * # Safety
 *
 * This function is unsafe because it dereferences a raw pointer. The caller must ensure that:
 * 1. The pointer is valid and points to a null-terminated string
 * 2. The string contains valid UTF-8 data
 */
__attribute__((aligned(8))) struct EvalResult exp_rs_eval(const char *expr);

/**
 * Creates a new evaluation context.
 *
 * This function creates a new evaluation context that can be used to store
 * variables, constants, and functions for use in expressions. The context
 * must be freed with exp_rs_context_free when no longer needed.
 *
 * # Returns
 *
 * A pointer to the new context, or NULL if allocation failed.
 *
 * # Safety
 *
 * This function is safe to call from C code. The returned pointer must be
 * passed to exp_rs_context_free when no longer needed to avoid memory leaks.
 */
__attribute__((aligned(8))) struct EvalContextOpaque *exp_rs_context_new(void);

/**
 * Frees an evaluation context previously created by exp_rs_context_new.
 *
 * This function releases all resources associated with the given context.
 * After calling this function, the context pointer is no longer valid and
 * should not be used.
 *
 * # Parameters
 *
 * * `ctx` - Pointer to the context to free, as returned by exp_rs_context_new
 *
 * # Safety
 *
 * This function is unsafe because it dereferences a raw pointer. The caller must ensure that:
 * 1. The pointer was returned by exp_rs_context_new
 * 2. The pointer has not already been freed
 * 3. The pointer is not used after calling this function
 */
__attribute__((aligned(8))) void exp_rs_context_free(struct EvalContextOpaque *ctx);

/**
 * Register an expression function with the given context.
 *
 * This function registers a new function defined by an expression string
 * that can be called in future expression evaluations.
 *
 * # Parameters
 *
 * * `ctx` - Pointer to the context, as returned by exp_rs_context_new
 * * `name` - The name of the function to register
 * * `params` - Array of parameter names the function will accept
 * * `param_count` - Number of parameters in the array
 * * `expression` - The expression string that defines the function behavior
 *
 * # Returns
 *
 * An EvalResult structure with:
 * - status=0 on success
 * - non-zero status with an error message on failure
 *
 * When status is non-zero, the error message must be freed with exp_rs_free_error.
 */
__attribute__((aligned(8)))
struct EvalResult exp_rs_context_register_expression_function(struct EvalContextOpaque *ctx,
                                                              const char *name,
                                                              const char *const *params,
                                                              uintptr_t param_count,
                                                              const char *expression);

/**
 * Unregister an expression function from the given context.
 *
 * This function removes an expression function that was previously registered
 * with exp_rs_context_register_expression_function. It only affects the current
 * context and does not modify parent contexts.
 *
 * # Warning
 *
 * Unregistering a function that is used by other expression functions may cause
 * runtime errors when those expressions are evaluated later. The AST cache is
 * cleared when a function is unregistered to prevent some issues.
 *
 * # Parameters
 *
 * * `ctx` - Pointer to the context, as returned by exp_rs_context_new
 * * `name` - The name of the expression function to unregister
 *
 * # Returns
 *
 * An EvalResult structure with:
 * - status=0 and value=1.0 if the function was found and removed
 * - status=0 and value=0.0 if the function was not found in this context
 * - non-zero status with an error message on failure
 *
 * When status is non-zero, the error message must be freed with exp_rs_free_error.
 */
__attribute__((aligned(8)))
struct EvalResult exp_rs_context_unregister_expression_function(struct EvalContextOpaque *ctx,
                                                                const char *name);

/**
 * Register a native function with the given context.
 *
 * This function registers a Rust function to be invoked from C expressions.
 * The native function will be available for use in expressions evaluated with this context.
 *
 * # Parameters
 *
 * * `ctx` - Pointer to the context, as returned by exp_rs_context_new
 * * `name` - The name of the function to register
 * * `arity` - Number of parameters the function accepts
 * * `func_ptr` - Function pointer to the implementation (C callback)
 *
 * # Returns
 *
 * An EvalResult structure with:
 * - status=0 on success
 * - non-zero status with an error message on failure
 *
 * When status is non-zero, the error message must be freed with exp_rs_free_error.
 */
__attribute__((aligned(8)))
struct EvalResult exp_rs_context_register_native_function(struct EvalContextOpaque *ctx,
                                                          const char *name,
                                                          uintptr_t arity,
                                                          Real (*func_ptr)(const Real*, uintptr_t));

/**
 * Set a parameter value in the context.
 *
 * This function adds or updates a variable in the evaluation context that can be
 * referenced in expressions evaluated with this context.
 *
 * # Parameters
 *
 * * `ctx` - Pointer to the context, as returned by exp_rs_context_new
 * * `name` - The name of the parameter to set
 * * `value` - The value to assign to the parameter
 *
 * # Returns
 *
 * An EvalResult structure with:
 * - status=0 on success
 * - non-zero status with an error message on failure
 *
 * When status is non-zero, the error message must be freed with exp_rs_free_error.
 */
__attribute__((aligned(8)))
struct EvalResult exp_rs_context_set_parameter(struct EvalContextOpaque *ctx,
                                               const char *name,
                                               Real value);

/**
 * Evaluates a mathematical expression using the given context.
 *
 * This function evaluates a mathematical expression string using the specified context,
 * which can contain variables, constants, and custom functions.
 *
 * # Parameters
 *
 * * `expr` - Null-terminated string containing the expression to evaluate
 * * `ctx` - Pointer to the context to use, as returned by exp_rs_context_new
 *
 * # Returns
 *
 * An EvalResult structure containing either the result value or an error message.
 *
 * # Safety
 *
 * This function is unsafe because it dereferences raw pointers. The caller must ensure that:
 * 1. The expression pointer is valid and points to a null-terminated string
 * 2. The string contains valid UTF-8 data
 * 3. The context pointer was returned by exp_rs_context_new and has not been freed
 */
__attribute__((aligned(8)))
struct EvalResult exp_rs_context_eval(const char *expr,
                                      struct EvalContextOpaque *ctx);

/**
 * Evaluates multiple expressions with multiple parameter sets in a batch.
 *
 * This function provides high-performance batch evaluation by:
 * - Parsing each expression only once
 * - Reusing a single evaluation engine for all evaluations
 * - Minimizing FFI overhead
 *
 * # Parameters
 *
 * * `request` - Pointer to a BatchEvalRequest structure containing:
 *   - `expressions`: Array of expression strings to evaluate
 *   - `expression_count`: Number of expressions
 *   - `param_names`: Array of parameter names
 *   - `param_count`: Number of parameters
 *   - `param_values`: 2D array of parameter values [param_idx][batch_idx]
 *   - `batch_size`: Number of items to evaluate
 *   - `results`: 2D array to store results [expr_idx][batch_idx]
 *   - `allocate_results`: Whether to allocate result arrays
 *   - `stop_on_error`: Whether to stop on first error
 *   - `statuses`: Optional array for error tracking
 * * `ctx` - Pointer to the evaluation context
 *
 * # Returns
 *
 * 0 on success, non-zero error code on failure:
 * - 1: NULL request or context
 * - 2: Invalid request (zero expressions or batch size)
 * - 3: NULL expression pointer
 * - 4: Invalid UTF-8 in expression
 * - 5: Expression parsing error
 * - 6: Evaluation error (when stop_on_error is true)
 * - 7: Memory allocation error
 *
 * # Safety
 *
 * This function is unsafe because it:
 * 1. Dereferences raw pointers
 * 2. Performs pointer arithmetic for array access
 * 3. Assumes arrays are properly sized as specified
 *
 * The caller must ensure:
 * - All pointers are valid and properly aligned
 * - Arrays have the specified dimensions
 * - The context is valid and not freed during evaluation
 */
__attribute__((aligned(8)))
int32_t exp_rs_batch_eval(const struct BatchEvalRequest *request,
                          struct EvalContextOpaque *ctx);

/**
 * Evaluates multiple expressions with batch allocation of results.
 *
 * This is a convenience wrapper around exp_rs_batch_eval that handles
 * result allocation for you. The allocated results must be freed using
 * exp_rs_batch_free_results.
 *
 * # Memory Management
 *
 * This function allocates memory for results in the following pattern:
 * 1. Creates Vec<Vec<Real>> for result buffers
 * 2. Converts to Box<[Vec<Real>]> and leaks it
 * 3. Creates Vec<*mut Real> for pointer array
 * 4. Converts to Box<[*mut Real]> and leaks it
 *
 * The exp_rs_batch_free_results function must be called to properly
 * deallocate this memory. Do not attempt to free the memory manually.
 *
 * # Parameters
 *
 * * `request` - Pointer to a BatchEvalRequest structure
 * * `ctx` - Pointer to the evaluation context
 * * `result` - Pointer to a BatchEvalResult structure to receive results
 *
 * # Returns
 *
 * 0 on success, non-zero error code on failure (same as exp_rs_batch_eval)
 *
 * # Safety
 *
 * This function has the same safety requirements as exp_rs_batch_eval.
 * Additionally, the caller must ensure that `result` points to valid memory.
 */
__attribute__((aligned(8)))
int32_t exp_rs_batch_eval_alloc(const struct BatchEvalRequest *request,
                                struct EvalContextOpaque *ctx,
                                struct BatchEvalResult *result);

/**
 * Frees results allocated by exp_rs_batch_eval_alloc.
 *
 * This function releases memory allocated by the batch evaluation functions
 * when allocate_results was true or when using exp_rs_batch_eval_alloc.
 *
 * # Parameters
 *
 * * `result` - Pointer to a BatchEvalResult structure containing allocated results
 *
 * # Safety
 *
 * This function is unsafe because it:
 * 1. Dereferences a raw pointer
 * 2. Assumes the results were allocated by this library
 *
 * The caller must ensure:
 * - The result pointer is valid
 * - The results were allocated by exp_rs_batch_eval_alloc
 * - The results have not already been freed
 */
__attribute__((aligned(8))) void exp_rs_batch_free_results(struct BatchEvalResult *result);

/**
 * Batch evaluate multiple expressions with a pre-existing context
 */
__attribute__((aligned(8)))
int32_t exp_rs_batch_eval_with_context(const struct BatchEvalRequest *request,
                                       const struct EvalContextOpaque *ctx);

/**
 * Creates a new batch builder for efficient expression evaluation.
 *
 * The batch builder allows you to:
 * - Pre-parse expressions once
 * - Reuse a single evaluation engine
 * - Update parameters efficiently
 * - Evaluate all expressions in one call
 *
 * # Returns
 *
 * A pointer to the new batch builder, or NULL on allocation failure.
 *
 * # Safety
 *
 * The returned pointer must be freed with `exp_rs_batch_builder_free`.
 */
__attribute__((aligned(8))) struct BatchBuilderOpaque *exp_rs_batch_builder_new(void);

/**
 * Frees a batch builder.
 *
 * # Safety
 *
 * This function is unsafe because it:
 * - Dereferences a raw pointer
 * - Frees memory allocated by Rust
 *
 * The caller must ensure:
 * - The pointer was allocated by `exp_rs_batch_builder_new`
 * - The pointer is not used after this call
 * - The pointer is not freed multiple times
 */
__attribute__((aligned(8))) void exp_rs_batch_builder_free(struct BatchBuilderOpaque *builder);

/**
 * Adds an expression to the batch builder.
 *
 * The expression is parsed immediately and cached for efficient evaluation.
 *
 * # Parameters
 *
 * * `builder` - Pointer to the batch builder
 * * `expr` - The expression string to add
 *
 * # Returns
 *
 * The index of the added expression (>= 0) on success, or negative error code:
 * - `-1`: NULL pointer
 * - `-2`: Parse error
 * - `-3`: Invalid UTF-8 in expression
 *
 * # Safety
 *
 * This function is unsafe because it dereferences raw pointers.
 * The caller must ensure all pointers are valid.
 */
__attribute__((aligned(8)))
int32_t exp_rs_batch_builder_add_expression(struct BatchBuilderOpaque *builder,
                                            const char *expr);

/**
 * Adds a parameter to the batch builder.
 *
 * # Parameters
 *
 * * `builder` - Pointer to the batch builder
 * * `name` - The parameter name
 * * `initial_value` - Initial value for the parameter
 *
 * # Returns
 *
 * The index of the added parameter (>= 0) on success, or negative error code:
 * - `-1`: NULL pointer
 * - `-2`: Duplicate parameter name or other error
 * - `-3`: Invalid UTF-8 in parameter name
 *
 * # Safety
 *
 * This function is unsafe because it dereferences raw pointers.
 * The caller must ensure all pointers are valid.
 */
__attribute__((aligned(8)))
int32_t exp_rs_batch_builder_add_parameter(struct BatchBuilderOpaque *builder,
                                           const char *name,
                                           Real initial_value);

/**
 * Sets a parameter value by index.
 *
 * This is the fastest way to update parameter values.
 *
 * # Parameters
 *
 * * `builder` - Pointer to the batch builder
 * * `idx` - Parameter index (from `add_parameter`)
 * * `value` - New value for the parameter
 *
 * # Returns
 *
 * 0 on success, negative error code on failure:
 * - `-1`: NULL pointer
 * - `-2`: Invalid parameter index
 *
 * # Safety
 *
 * This function is unsafe because it dereferences raw pointers.
 */
__attribute__((aligned(8)))
int32_t exp_rs_batch_builder_set_param(struct BatchBuilderOpaque *builder,
                                       uintptr_t idx,
                                       Real value);

/**
 * Sets a parameter value by name.
 *
 * This is more convenient but slower than setting by index.
 *
 * # Parameters
 *
 * * `builder` - Pointer to the batch builder
 * * `name` - Parameter name
 * * `value` - New value for the parameter
 *
 * # Returns
 *
 * 0 on success, negative error code on failure:
 * - `-1`: NULL pointer
 * - `-2`: Unknown parameter name
 * - `-3`: Invalid UTF-8 in parameter name
 *
 * # Safety
 *
 * This function is unsafe because it dereferences raw pointers.
 */
__attribute__((aligned(8)))
int32_t exp_rs_batch_builder_set_param_by_name(struct BatchBuilderOpaque *builder,
                                               const char *name,
                                               Real value);

/**
 * Evaluates all expressions with current parameter values.
 *
 * This function updates the context with current parameter values and
 * evaluates all expressions using cached ASTs and a reusable engine.
 *
 * # Parameters
 *
 * * `builder` - Pointer to the batch builder
 * * `ctx` - Pointer to the evaluation context
 *
 * # Returns
 *
 * 0 on success, negative error code on failure:
 * - `-1`: NULL pointer
 * - `-2`: Evaluation error
 *
 * # Safety
 *
 * This function is unsafe because it dereferences raw pointers.
 */
__attribute__((aligned(8)))
int32_t exp_rs_batch_builder_eval(struct BatchBuilderOpaque *builder,
                                  struct EvalContextOpaque *ctx);

/**
 * Gets the result of a specific expression by index.
 *
 * # Parameters
 *
 * * `builder` - Pointer to the batch builder
 * * `expr_idx` - Expression index (from `add_expression`)
 *
 * # Returns
 *
 * The result value, or NaN if the index is invalid.
 *
 * # Safety
 *
 * This function is unsafe because it dereferences raw pointers.
 */
__attribute__((aligned(8)))
Real exp_rs_batch_builder_get_result(const struct BatchBuilderOpaque *builder,
                                     uintptr_t expr_idx);

/**
 * Gets the number of parameters in the batch builder.
 *
 * # Parameters
 *
 * * `builder` - Pointer to the batch builder
 *
 * # Returns
 *
 * The number of parameters, or 0 if the pointer is NULL.
 *
 * # Safety
 *
 * This function is unsafe because it dereferences raw pointers.
 */
__attribute__((aligned(8)))
uintptr_t exp_rs_batch_builder_param_count(const struct BatchBuilderOpaque *builder);

/**
 * Gets the number of expressions in the batch builder.
 *
 * # Parameters
 *
 * * `builder` - Pointer to the batch builder
 *
 * # Returns
 *
 * The number of expressions, or 0 if the pointer is NULL.
 *
 * # Safety
 *
 * This function is unsafe because it dereferences raw pointers.
 */
__attribute__((aligned(8)))
uintptr_t exp_rs_batch_builder_expression_count(const struct BatchBuilderOpaque *builder);

#if defined(EXP_RS_CUSTOM_ALLOC)
extern void *exp_rs_malloc(uintptr_t size);
#endif

#if defined(EXP_RS_CUSTOM_ALLOC)
extern void exp_rs_free(void *ptr);
#endif

#if !defined(EXP_RS_CUSTOM_ALLOC)
extern void *malloc(uintptr_t size);
#endif

#if !defined(EXP_RS_CUSTOM_ALLOC)
extern void free(void *ptr);
#endif

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* EXP_RS_H */

#ifndef EXP_RS_H
#define EXP_RS_H

#pragma once

/* Warning: This file is autogenerated by cbindgen. Do not modify manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>


/**
 * FFI error codes (negative to distinguish from ExprError codes)
 */
#define FFI_ERROR_NULL_POINTER -1

#define FFI_ERROR_INVALID_UTF8 -2

#define FFI_ERROR_NO_ARENA_AVAILABLE -3

#define FFI_ERROR_CANNOT_GET_MUTABLE_ACCESS -4

#define EXP_RS_MAX_VARIABLES 16

#define EXP_RS_MAX_CONSTANTS 8

#define EXP_RS_MAX_ARRAYS 4

#define EXP_RS_MAX_ATTRIBUTES 4

#define EXP_RS_MAX_NESTED_ARRAYS 2

#define EXP_RS_MAX_AST_CACHE 16

#define EXP_RS_MAX_NATIVE_FUNCTIONS 64

#define EXP_RS_MAX_EXPRESSION_FUNCTIONS 8

#define EXP_RS_MAX_ATTR_KEYS 4

#define EXP_RS_MAX_KEY_LENGTH 32

#define EXP_RS_MAX_FUNCTION_NAME_LENGTH 32

/**
 * Opaque type for evaluation context
 */
typedef struct ExprContext {
  uint8_t _private[0];
} ExprContext;

#if defined(USE_F32)
/**
 * Define the floating-point type based on feature flags
 */
typedef float Real;
#endif

#if !defined(USE_F32)
typedef double Real;
#endif

/**
 * Native function signature
 */
typedef Real (*NativeFunc)(const Real *args, uintptr_t n_args);

/**
 * Opaque type for expression batch
 */
typedef struct ExprBatch {
  uint8_t _private[0];
} ExprBatch;

/**
 * Opaque type for memory arena
 */
typedef struct ExprArena {
  uint8_t _private[0];
} ExprArena;

/**
 * Result structure for FFI operations
 */
typedef struct ExprResult {
  /**
   * Error code: 0 for success, positive for ExprError, negative for FFI errors
   */
  int32_t status;
  /**
   * Result value (valid only if status == 0)
   */
  Real value;
  /**
   * Result index (for functions that return an index)
   */
  int32_t index;
  /**
   * Error message (NULL on success, must be freed with expr_free_error)
   */
  char *error;
} ExprResult;

/**
 * Opaque type for expression session (single expression evaluation)
 */
typedef struct ExprSession {
  uint8_t _private[0];
} ExprSession;

#if defined(USE_F32)
#define TEST_PRECISION 1e-6
#endif

#if !defined(USE_F32)
#define TEST_PRECISION 1e-10
#endif

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Register a panic handler
 *
 * # Parameters
 * - `flag_ptr`: Pointer to an integer that will be set to 1 on panic
 * - `log_func`: Optional logging function pointer (can be NULL)
 *
 * # Safety
 * The provided pointers must remain valid for the lifetime of the program
 */
__attribute__((aligned(8)))
void exp_rs_register_panic_handler(int32_t *flag_ptr,
                                   const void *log_func);

/**
 * Free an error message string
 *
 * # Safety
 * The pointer must have been returned by an expr_* function
 */
__attribute__((aligned(8))) void expr_free_error(char *ptr);

/**
 * Create a new evaluation context
 *
 * The context holds function definitions and can be reused across evaluations.
 *
 * # Returns
 * Pointer to new context, or NULL on allocation failure
 *
 * # Safety
 * The returned pointer must be freed with expr_context_free()
 */
__attribute__((aligned(8))) struct ExprContext *expr_context_new(void);

/**
 * Create a new evaluation context without any pre-registered functions
 *
 * This creates a context with no built-in functions or constants.
 * Note that basic operators (+, -, *, /, %, <, >, <=, >=, ==, !=) are still
 * available as they are handled by the parser, not the function registry.
 *
 * # Returns
 * Pointer to new empty context, or NULL on allocation failure
 *
 * # Safety
 * The returned pointer must be freed with expr_context_free()
 *
 * # Example
 * ```c
 * ExprContext* ctx = expr_context_new_empty();
 * // Must register all functions manually
 * expr_context_add_function(ctx, "+", 2, add_func);
 * expr_context_add_function(ctx, "*", 2, mul_func);
 * ```
 */
__attribute__((aligned(8))) struct ExprContext *expr_context_new_empty(void);

/**
 * Free an evaluation context
 *
 * # Safety
 * - The pointer must have been created by expr_context_new()
 * - The pointer must not be used after calling this function
 */
__attribute__((aligned(8))) void expr_context_free(struct ExprContext *ctx);

/**
 * Get the count of native functions in a context
 */
__attribute__((aligned(8)))
uintptr_t expr_context_native_function_count(const struct ExprContext *ctx);

/**
 * Get the count of expression functions in a context
 */
__attribute__((aligned(8)))
uintptr_t expr_context_expression_function_count(const struct ExprContext *ctx);

/**
 * Get a native function name by index
 * Returns the length of the name, or 0 if index is out of bounds
 * If buffer is NULL, just returns the length needed
 */
__attribute__((aligned(8)))
uintptr_t expr_context_get_native_function_name(const struct ExprContext *ctx,
                                                uintptr_t index,
                                                uint8_t *buffer,
                                                uintptr_t buffer_size);

/**
 * Get an expression function name by index
 * Returns the length of the name, or 0 if index is out of bounds
 * If buffer is NULL, just returns the length needed
 */
__attribute__((aligned(8)))
uintptr_t expr_context_get_expression_function_name(const struct ExprContext *ctx,
                                                    uintptr_t index,
                                                    uint8_t *buffer,
                                                    uintptr_t buffer_size);

/**
 * Add a native function to the context
 *
 * # Parameters
 * - `ctx`: The context
 * - `name`: Function name (must be valid UTF-8)
 * - `arity`: Number of arguments the function expects
 * - `func`: Function pointer
 *
 * # Returns
 * 0 on success, non-zero on error
 */
__attribute__((aligned(8)))
int32_t expr_context_add_function(struct ExprContext *ctx,
                                  const char *name,
                                  uintptr_t arity,
                                  NativeFunc func);

/**
 * Add an expression function to the context
 *
 * Expression functions are mathematical expressions that can call other functions.
 * They are parsed and expanded when used.
 *
 * # Parameters
 * - `ctx`: The context
 * - `name`: Function name (must be valid UTF-8)
 * - `params`: Comma-separated parameter names (e.g., "x,y,z")
 * - `expression`: The expression string defining the function
 *
 * # Returns
 * 0 on success, non-zero on error
 */
__attribute__((aligned(8)))
int32_t expr_context_add_expression_function(struct ExprContext *ctx,
                                             const char *name,
                                             const char *params,
                                             const char *expression);

/**
 * Remove an expression function from the context
 *
 * # Parameters
 * - `ctx`: The context
 * - `name`: Function name to remove
 *
 * # Returns
 * - 1 if the function was removed
 * - 0 if the function didn't exist
 * - negative error code on failure
 */
__attribute__((aligned(8)))
int32_t expr_context_remove_expression_function(struct ExprContext *ctx,
                                                const char *name);

/**
 * Add an expression function to a batch
 *
 * Expression functions are mathematical expressions that can call other functions.
 * They are specific to this batch and take precedence over context functions.
 *
 * # Parameters
 * - `batch`: The batch
 * - `name`: Function name (must be valid UTF-8)
 * - `params`: Comma-separated parameter names (e.g., "x,y,z")
 * - `expression`: The expression string defining the function
 *
 * # Returns
 * 0 on success, non-zero on error
 */
__attribute__((aligned(8)))
int32_t expr_batch_add_expression_function(struct ExprBatch *batch,
                                           const char *name,
                                           const char *params,
                                           const char *expression);

/**
 * Remove an expression function from a batch
 *
 * # Parameters
 * - `batch`: The batch
 * - `name`: Function name to remove
 *
 * # Returns
 * - 1 if the function was removed
 * - 0 if the function didn't exist
 * - negative error code on failure
 */
__attribute__((aligned(8)))
int32_t expr_batch_remove_expression_function(struct ExprBatch *batch,
                                              const char *name);

/**
 * Create a new memory arena
 *
 * # Parameters
 * - `size_hint`: Suggested size in bytes (0 for default)
 *
 * # Returns
 * Pointer to new arena, or NULL on allocation failure
 *
 * # Safety
 * The returned pointer must be freed with expr_arena_free()
 */
__attribute__((aligned(8))) struct ExprArena *expr_arena_new(uintptr_t size_hint);

/**
 * Free a memory arena
 *
 * # Safety
 * - The pointer must have been created by expr_arena_new()
 * - All batches using this arena must be freed first
 */
__attribute__((aligned(8))) void expr_arena_free(struct ExprArena *arena);

/**
 * Reset an arena for reuse
 *
 * This clears all allocations but keeps the memory for reuse.
 *
 * # Safety
 * No references to arena-allocated data must exist
 */
__attribute__((aligned(8))) void expr_arena_reset(struct ExprArena *arena);

/**
 * Create a new expression batch
 *
 * # Parameters
 * - `arena`: Memory arena for allocations
 *
 * # Returns
 * Pointer to new batch, or NULL on failure
 *
 * # Safety
 * - The arena must remain valid for the batch's lifetime
 * - The returned pointer must be freed with expr_batch_free()
 */
__attribute__((aligned(8))) struct ExprBatch *expr_batch_new(struct ExprArena *arena);

/**
 * Free an expression batch
 *
 * # Safety
 * The pointer must have been created by expr_batch_new()
 */
__attribute__((aligned(8))) void expr_batch_free(struct ExprBatch *batch);

/**
 * Add an expression to the batch
 *
 * # Parameters
 * - `batch`: The batch
 * - `expr`: Expression string (must be valid UTF-8)
 *
 * # Returns
 * ExprResult with index on success, or error details on failure
 */
__attribute__((aligned(8)))
struct ExprResult expr_batch_add_expression(struct ExprBatch *batch,
                                            const char *expr);

/**
 * Add a variable to the batch
 *
 * # Parameters
 * - `batch`: The batch
 * - `name`: Variable name (must be valid UTF-8)
 * - `value`: Initial value
 *
 * # Returns
 * ExprResult with index on success, or error details on failure
 */
__attribute__((aligned(8)))
struct ExprResult expr_batch_add_variable(struct ExprBatch *batch,
                                          const char *name,
                                          Real value);

/**
 * Update a variable value by index
 *
 * # Parameters
 * - `batch`: The batch
 * - `index`: Variable index from expr_batch_add_variable()
 * - `value`: New value
 *
 * # Returns
 * 0 on success, negative error code on failure
 */
__attribute__((aligned(8)))
int32_t expr_batch_set_variable(struct ExprBatch *batch,
                                uintptr_t index,
                                Real value);

/**
 * Evaluate all expressions in the batch
 *
 * # Parameters
 * - `batch`: The batch
 * - `ctx`: Optional context with functions (can be NULL)
 *
 * # Returns
 * 0 on success, negative error code on failure
 */
__attribute__((aligned(8)))
int32_t expr_batch_evaluate(struct ExprBatch *batch,
                            struct ExprContext *ctx);

/**
 * Get the result of an expression
 *
 * # Parameters
 * - `batch`: The batch
 * - `index`: Expression index from expr_batch_add_expression()
 *
 * # Returns
 * Result value, or NaN if index is invalid
 */
__attribute__((aligned(8)))
Real expr_batch_get_result(const struct ExprBatch *batch,
                           uintptr_t index);

/**
 * Evaluate all expressions in the batch with detailed error reporting
 *
 * # Parameters
 * - `batch`: The batch
 * - `ctx`: Optional context with functions (can be NULL)
 *
 * # Returns
 * ExprResult with status 0 on success, or error details on failure
 */
__attribute__((aligned(8)))
struct ExprResult expr_batch_evaluate_ex(struct ExprBatch *batch,
                                         struct ExprContext *ctx);

/**
 * Initialize the arena pool
 *
 * # Parameters
 * - `max_arenas`: Maximum number of arenas in the pool
 *
 * # Returns
 * true on success, false if already initialized
 */
__attribute__((aligned(8))) bool expr_pool_init(uintptr_t max_arenas);

/**
 * Create a new expression session
 *
 * Automatically gets an arena from the pool.
 *
 * # Returns
 * Pointer to new session, or NULL if no arenas available
 *
 * # Safety
 * The returned pointer must be freed with expr_session_free()
 */
__attribute__((aligned(8))) struct ExprSession *expr_session_new(void);

/**
 * Free an expression session
 *
 * This returns the arena to the pool for reuse.
 *
 * # Safety
 * The pointer must have been created by expr_session_new()
 */
__attribute__((aligned(8))) void expr_session_free(struct ExprSession *session);

/**
 * Parse an expression in the session
 *
 * # Parameters
 * - `session`: The session
 * - `expr`: Expression string (must be valid UTF-8)
 *
 * # Returns
 * 0 on success, negative error code on failure
 */
__attribute__((aligned(8)))
int32_t expr_session_parse(struct ExprSession *session,
                           const char *expr);

/**
 * Parse an expression in the session with detailed error reporting
 *
 * # Parameters
 * - `session`: The session
 * - `expr`: Expression string (must be valid UTF-8)
 *
 * # Returns
 * ExprResult with status 0 on success, or error details on failure
 */
__attribute__((aligned(8)))
struct ExprResult expr_session_parse_ex(struct ExprSession *session,
                                        const char *expr);

/**
 * Add a variable to the session
 *
 * # Parameters
 * - `session`: The session
 * - `name`: Variable name (must be valid UTF-8)
 * - `value`: Initial value
 *
 * # Returns
 * Variable index on success, negative error code on failure
 */
__attribute__((aligned(8)))
int32_t expr_session_add_variable(struct ExprSession *session,
                                  const char *name,
                                  Real value);

/**
 * Update a variable value by name
 *
 * # Parameters
 * - `session`: The session
 * - `name`: Variable name
 * - `value`: New value
 *
 * # Returns
 * 0 on success, negative error code on failure
 */
__attribute__((aligned(8)))
int32_t expr_session_set_variable(struct ExprSession *session,
                                  const char *name,
                                  Real value);

/**
 * Evaluate the expression
 *
 * # Parameters
 * - `session`: The session
 * - `ctx`: Optional context with functions (can be NULL)
 * - `result`: Pointer to store the result
 *
 * # Returns
 * 0 on success, negative error code on failure
 */
__attribute__((aligned(8)))
int32_t expr_session_evaluate(struct ExprSession *session,
                              struct ExprContext *ctx,
                              Real *result);

/**
 * Evaluate the expression with detailed error reporting
 *
 * # Parameters
 * - `session`: The session
 * - `ctx`: Optional context with functions (can be NULL)
 *
 * # Returns
 * ExprResult with value on success, or error details on failure
 */
__attribute__((aligned(8)))
struct ExprResult expr_session_evaluate_ex(struct ExprSession *session,
                                           struct ExprContext *ctx);

/**
 * Estimate arena size needed for expressions
 *
 * # Parameters
 * - `expression_count`: Number of expressions
 * - `total_expr_length`: Total length of all expression strings
 * - `param_count`: Number of parameters
 * - `estimated_iterations`: Estimated evaluation iterations
 *
 * # Returns
 * Recommended arena size in bytes
 */
__attribute__((aligned(8)))
uintptr_t expr_estimate_arena_size(uintptr_t expression_count,
                                   uintptr_t total_expr_length,
                                   uintptr_t param_count,
                                   uintptr_t _estimated_iterations);

/**
 * Force a panic for testing purposes (only available in debug builds)
 */
__attribute__((aligned(8))) void exp_rs_test_trigger_panic(void);

#if defined(EXP_RS_CUSTOM_ALLOC)
extern void *exp_rs_malloc(uintptr_t size);
#endif

#if defined(EXP_RS_CUSTOM_ALLOC)
extern void exp_rs_free(void *ptr);
#endif

#if !defined(EXP_RS_CUSTOM_ALLOC)
extern void *malloc(uintptr_t size);
#endif

#if !defined(EXP_RS_CUSTOM_ALLOC)
extern void free(void *ptr);
#endif

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* EXP_RS_H */

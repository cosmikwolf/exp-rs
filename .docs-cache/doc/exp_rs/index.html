<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="exp-rs"><title>exp_rs - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-84e720fa.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="exp_rs" data-themes="" data-resource-suffix="" data-rustdoc-version="1.89.0-nightly (45f256d9d 2025-05-27)" data-channel="nightly" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-4e99c027.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-fd3af306.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../exp_rs/index.html">exp_rs</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#overview" title="Overview">Overview</a></li><li><a href="#quick-start" title="Quick Start">Quick Start</a></li><li><a href="#supported-grammar" title="Supported Grammar">Supported Grammar</a><ul><li><a href="#operator-precedence-and-associativity" title="Operator Precedence and Associativity">Operator Precedence and Associativity</a></li><li><a href="#built-in-functions" title="Built-in Functions">Built-in Functions</a></li><li><a href="#built-in-constants" title="Built-in Constants">Built-in Constants</a></li></ul></li><li><a href="#feature-flags" title="Feature Flags">Feature Flags</a></li><li><a href="#embedded-systems-support" title="Embedded Systems Support">Embedded Systems Support</a></li><li><a href="#using-variables-and-constants" title="Using Variables and Constants">Using Variables and Constants</a></li><li><a href="#arrays-and-object-attributes" title="Arrays and Object Attributes">Arrays and Object Attributes</a></li><li><a href="#custom-functions" title="Custom Functions">Custom Functions</a><ul><li><a href="#native-functions" title="Native Functions">Native Functions</a></li><li><a href="#expression-functions" title="Expression Functions">Expression Functions</a></li></ul></li><li><a href="#performance-optimization-with-ast-caching" title="Performance Optimization with AST Caching">Performance Optimization with AST Caching</a></li><li><a href="#using-on-embedded-systems-no_std" title="Using on Embedded Systems (no_std)">Using on Embedded Systems (no_std)</a></li><li><a href="#disabling-built-in-math-functions" title="Disabling Built-in Math Functions">Disabling Built-in Math Functions</a></li><li><a href="#error-handling" title="Error Handling">Error Handling</a></li><li><a href="#attribution" title="Attribution">Attribution</a></li></ul><h3><a href="#reexports">Crate Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>exp_rs</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/exp_rs/lib.rs.html#2-513">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>exp-rs</p>
<p>A minimal, extensible, no_std-friendly math expression parser and evaluator for Rust.</p>
<h2 id="overview"><a class="doc-anchor" href="#overview">§</a>Overview</h2>
<p>exp-rs is a math expression parser and evaluator library designed to be simple, extensible, and compatible with no_std environments, designed for use on embedded targets.</p>
<p>Key features:</p>
<ul>
<li>Configurable floating-point precision (f32/f64)</li>
<li>Support for user-defined variables, constants, arrays, attributes, and functions</li>
<li>Built-in math functions (sin, cos, pow, etc.) that can be enabled/disabled</li>
<li>Ability to override any built-in function at runtime</li>
<li>Array access with <code>array[index]</code> syntax</li>
<li>Object attributes with <code>object.attribute</code> syntax</li>
<li>Standard function call syntax with parentheses (<code>sin(x)</code>, <code>cos(y)</code>, etc.)</li>
<li>Comprehensive error handling</li>
<li>No_std compatibility for embedded systems</li>
</ul>
<h2 id="quick-start"><a class="doc-anchor" href="#quick-start">§</a>Quick Start</h2>
<p>Here’s a basic example of evaluating a math expression:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>exp_rs::interp;

<span class="kw">fn </span>main() {
    <span class="comment">// Simple expression evaluation
    </span><span class="kw">let </span>result = interp(<span class="string">"2 + 3 * 4"</span>, <span class="prelude-val">None</span>).unwrap();
    <span class="macro">assert_eq!</span>(result, <span class="number">14.0</span>); <span class="comment">// 2 + (3 * 4) = 14

    </span><span class="attr">#[cfg(feature = <span class="string">"libm"</span>)]
    </span>{
        <span class="comment">// Using built-in functions and constants
        </span><span class="kw">let </span>result = interp(<span class="string">"sin(pi/4) + cos(pi/4)"</span>, <span class="prelude-val">None</span>).unwrap();
        <span class="macro">assert!</span>(result - <span class="number">1.414 </span>&lt; <span class="number">0.001</span>); <span class="comment">// Approximately √2
    </span>}
}</code></pre></div>
<h2 id="supported-grammar"><a class="doc-anchor" href="#supported-grammar">§</a>Supported Grammar</h2>
<p>exp-rs supports a superset of the original TinyExpr grammar, closely matching the tinyexpr++ grammar, including:</p>
<ul>
<li>Multi-character operators: <code>&amp;&amp;</code>, <code>||</code>, <code>==</code>, <code>!=</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&lt;&lt;&lt;</code>, <code>&gt;&gt;&gt;</code>, <code>**</code>, <code>&lt;&gt;</code></li>
<li>Logical operators (<code>&amp;&amp;</code>, <code>||</code>) with short-circuit evaluation</li>
<li>Logical, comparison, bitwise, and exponentiation operators with correct precedence and associativity</li>
<li>List expressions and both comma and semicolon as separators</li>
<li>Standard function call syntax with parentheses</li>
<li>Array and attribute access</li>
<li>Right-associative exponentiation</li>
</ul>
<h3 id="operator-precedence-and-associativity"><a class="doc-anchor" href="#operator-precedence-and-associativity">§</a>Operator Precedence and Associativity</h3>
<p>From lowest to highest precedence:</p>
<div><table><thead><tr><th>Precedence</th><th>Operators</th><th>Associativity</th></tr></thead><tbody>
<tr><td>1</td><td><code>,</code> <code>;</code></td><td>Left</td></tr>
<tr><td>2</td><td>`</td><td></td></tr>
<tr><td>3</td><td><code>&amp;&amp;</code></td><td>Left</td></tr>
<tr><td>4</td><td>`</td><td>`</td></tr>
<tr><td>6</td><td><code>&amp;</code></td><td>Left (bitwise AND)</td></tr>
<tr><td>7</td><td><code>==</code> <code>!=</code> <code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code> <code>&lt;&gt;</code></td><td>Left (comparison)</td></tr>
<tr><td>8</td><td><code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>&lt;&lt;&lt;</code> <code>&gt;&gt;&gt;</code></td><td>Left (bit shifts)</td></tr>
<tr><td>9</td><td><code>+</code> <code>-</code></td><td>Left</td></tr>
<tr><td>10</td><td><code>*</code> <code>/</code> <code>%</code></td><td>Left</td></tr>
<tr><td>14</td><td>unary <code>+</code> <code>-</code> <code>~</code></td><td>Right (unary)</td></tr>
<tr><td>15</td><td><code>^</code></td><td>Right</td></tr>
<tr><td>16</td><td><code>**</code></td><td>Right</td></tr>
</tbody></table>
</div><h3 id="built-in-functions"><a class="doc-anchor" href="#built-in-functions">§</a>Built-in Functions</h3>
<p>The following functions are available by default when the <code>libm</code> feature is enabled. Without the <code>libm</code> feature,
these functions will not be automatically registered and must be defined by the user with native or expression functions:</p>
<ul>
<li>Trigonometric: <code>sin</code>, <code>cos</code>, <code>tan</code>, <code>asin</code>, <code>acos</code>, <code>atan</code>, <code>atan2</code></li>
<li>Hyperbolic: <code>sinh</code>, <code>cosh</code>, <code>tanh</code></li>
<li>Exponential/Logarithmic: <code>exp</code>, <code>log</code>, <code>log10</code>, <code>ln</code></li>
<li>Power/Root: <code>sqrt</code>, <code>pow</code></li>
<li>Rounding: <code>ceil</code>, <code>floor</code></li>
<li>Comparison: <code>max</code>, <code>min</code></li>
<li>Misc: <code>abs</code>, <code>sign</code></li>
</ul>
<h3 id="built-in-constants"><a class="doc-anchor" href="#built-in-constants">§</a>Built-in Constants</h3>
<ul>
<li><code>pi</code>: 3.14159… (π)</li>
<li><code>e</code>: 2.71828… (Euler’s number)</li>
</ul>
<h2 id="feature-flags"><a class="doc-anchor" href="#feature-flags">§</a>Feature Flags</h2>
<ul>
<li><code>libm</code>: Enables built-in math functions using the libm library. Without this feature, you must register your own math functions.</li>
<li><code>f32</code>: Use 32-bit floating point (single precision) for calculations</li>
</ul>
<p>When <code>f32</code> is not specified, 64-bit floating point (double precision) is used by default.</p>
<h2 id="embedded-systems-support"><a class="doc-anchor" href="#embedded-systems-support">§</a>Embedded Systems Support</h2>
<p>exp-rs provides extensive support for embedded systems:</p>
<ul>
<li><code>no_std</code> compatible with the <code>alloc</code> crate</li>
<li>Configurable precision with <code>f32</code>/<code>f64</code> options</li>
<li>Option to disable built-in math functions and provide custom implementations</li>
<li>Tested example using qemu CMSIS-DSP math functions (test in repo)</li>
<li>Meson build system integration for cross-compilation</li>
<li>QEMU test harness for validating on ARM hardware</li>
<li>Optional C FFI for calling from non-Rust code</li>
</ul>
<h2 id="using-variables-and-constants"><a class="doc-anchor" href="#using-variables-and-constants">§</a>Using Variables and Constants</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern crate </span>alloc;
<span class="kw">use </span>exp_rs::context::EvalContext;
<span class="kw">use </span>exp_rs::interp;
<span class="kw">use </span>alloc::rc::Rc;

<span class="comment">// Create an evaluation context
</span><span class="kw">let </span><span class="kw-2">mut </span>ctx = EvalContext::new();

<span class="comment">// Add variables
</span>ctx.set_parameter(<span class="string">"x"</span>, <span class="number">5.0</span>);
ctx.set_parameter(<span class="string">"y"</span>, <span class="number">10.0</span>);

<span class="comment">// Add constants - these won't change once set
</span>ctx.constants.insert(<span class="string">"FACTOR"</span>.try_into().unwrap(), <span class="number">2.5</span>).unwrap();

<span class="comment">// Evaluate expression with variables and constants
</span><span class="kw">let </span>result = interp(<span class="string">"x + y * FACTOR"</span>, <span class="prelude-val">Some</span>(Rc::new(ctx))).unwrap();
<span class="comment">// Result: 30.0 (5 + (10 * 2.5) = 30)</span></code></pre></div>
<h2 id="arrays-and-object-attributes"><a class="doc-anchor" href="#arrays-and-object-attributes">§</a>Arrays and Object Attributes</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern crate </span>alloc;
<span class="kw">use </span>exp_rs::interp;
<span class="kw">use </span>exp_rs::context::EvalContext;
<span class="kw">use </span>heapless::FnvIndexMap;
<span class="kw">use </span>alloc::rc::Rc;

<span class="comment">// Create an evaluation context
</span><span class="kw">let </span><span class="kw-2">mut </span>ctx = EvalContext::new();
<span class="comment">// Add an array
</span>ctx.arrays.insert(<span class="string">"data"</span>.try_into().unwrap(), <span class="macro">vec!</span>[<span class="number">10.0</span>, <span class="number">20.0</span>, <span class="number">30.0</span>, <span class="number">40.0</span>, <span class="number">50.0</span>]).unwrap();

<span class="comment">// Add an object with attributes
</span><span class="kw">let </span><span class="kw-2">mut </span>point = FnvIndexMap::new();
point.insert(<span class="string">"x"</span>.try_into().unwrap(), <span class="number">3.0</span>).unwrap();
point.insert(<span class="string">"y"</span>.try_into().unwrap(), <span class="number">4.0</span>).unwrap();
ctx.attributes.insert(<span class="string">"point"</span>.try_into().unwrap(), point).unwrap();
<span class="kw">let </span>ctx_rc = Rc::new(ctx);

<span class="comment">// Access array elements in expressions
</span>interp(<span class="string">"data[2]"</span>, <span class="prelude-val">Some</span>(Rc::clone(<span class="kw-2">&amp;</span>ctx_rc))).unwrap(); <span class="comment">// Returns 30.0

// Access attributes in expressions
</span>interp(<span class="string">"point.x + point.y"</span>, <span class="prelude-val">Some</span>(Rc::clone(<span class="kw-2">&amp;</span>ctx_rc))).unwrap(); <span class="comment">// Returns 7.0

// Combine array and attribute access in expressions
</span>interp(<span class="string">"sqrt(point.x^2 + point.y^2) + data[0]"</span>, <span class="prelude-val">Some</span>(Rc::clone(<span class="kw-2">&amp;</span>ctx_rc))).unwrap();
<span class="comment">// Result: sqrt(3^2 + 4^2) + 10 = 5 + 10 = 15</span></code></pre></div>
<h2 id="custom-functions"><a class="doc-anchor" href="#custom-functions">§</a>Custom Functions</h2>
<p>exp-rs allows you to define custom functions in two ways:</p>
<h3 id="native-functions"><a class="doc-anchor" href="#native-functions">§</a>Native Functions</h3>
<p>Native functions can be defined at compile time:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern crate </span>alloc;
<span class="kw">use </span>exp_rs::context::EvalContext;
<span class="kw">use </span>exp_rs::engine::interp;
<span class="kw">use </span>alloc::rc::Rc;

<span class="kw">fn </span>main() {
    <span class="kw">let </span><span class="kw-2">mut </span>ctx = EvalContext::new();

    <span class="comment">// Register a native function that sums all arguments
    </span>ctx.register_native_function(<span class="string">"sum"</span>, <span class="number">3</span>, |args| {
        args.iter().sum()
    });

    <span class="comment">// Use the custom function
    </span><span class="kw">let </span>result = interp(<span class="string">"sum(1, 2, 3)"</span>, <span class="prelude-val">Some</span>(Rc::new(ctx))).unwrap();
    <span class="macro">assert_eq!</span>(result, <span class="number">6.0</span>);
}</code></pre></div>
<h3 id="expression-functions"><a class="doc-anchor" href="#expression-functions">§</a>Expression Functions</h3>
<p>Expression functions can be registered and passed into the library at runtime:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern crate </span>alloc;
<span class="kw">use </span>exp_rs::context::EvalContext;
<span class="kw">use </span>exp_rs::engine::interp;
<span class="kw">use </span>alloc::rc::Rc;

<span class="kw">fn </span>main() {
    <span class="kw">let </span><span class="kw-2">mut </span>ctx = EvalContext::new();

    <span class="comment">// Register an expression function
    </span>ctx.register_expression_function(
        <span class="string">"hypotenuse"</span>,
        <span class="kw-2">&amp;</span>[<span class="string">"a"</span>, <span class="string">"b"</span>],
        <span class="string">"sqrt(a^2 + b^2)"
    </span>).unwrap();

    <span class="comment">// Use the custom function
    </span><span class="kw">let </span>result = interp(<span class="string">"hypotenuse(3, 4)"</span>, <span class="prelude-val">Some</span>(Rc::new(ctx))).unwrap();
    <span class="macro">assert_eq!</span>(result, <span class="number">5.0</span>);
}</code></pre></div>
<h2 id="performance-optimization-with-ast-caching"><a class="doc-anchor" href="#performance-optimization-with-ast-caching">§</a>Performance Optimization with AST Caching</h2>
<p>For repeated evaluations of the same expression with different variables:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern crate </span>alloc;
<span class="kw">use </span>exp_rs::context::EvalContext;
<span class="kw">use </span>exp_rs::engine::interp;
<span class="kw">use </span>alloc::rc::Rc;

<span class="kw">fn </span>main() {
    <span class="kw">let </span><span class="kw-2">mut </span>ctx = EvalContext::new();
    ctx.enable_ast_cache(); <span class="comment">// Enable AST caching

    // First evaluation will parse and cache the AST
    </span>ctx.set_parameter(<span class="string">"x"</span>, <span class="number">1.0</span>);
    <span class="kw">let </span>result1 = interp(<span class="string">"x^2 + 2*x + 1"</span>, <span class="prelude-val">Some</span>(Rc::new(ctx.clone()))).unwrap();
    <span class="macro">assert_eq!</span>(result1, <span class="number">4.0</span>); <span class="comment">// 1^2 + 2*1 + 1 = 4

    // Subsequent evaluations with the same expression will reuse the cached AST
    </span>ctx.set_parameter(<span class="string">"x"</span>, <span class="number">2.0</span>);
    <span class="kw">let </span>result2 = interp(<span class="string">"x^2 + 2*x + 1"</span>, <span class="prelude-val">Some</span>(Rc::new(ctx.clone()))).unwrap();
    <span class="macro">assert_eq!</span>(result2, <span class="number">9.0</span>); <span class="comment">// 2^2 + 2*2 + 1 = 9

    // This is much faster for repeated evaluations
    </span>ctx.set_parameter(<span class="string">"x"</span>, <span class="number">3.0</span>);
    <span class="kw">let </span>result3 = interp(<span class="string">"x^2 + 2*x + 1"</span>, <span class="prelude-val">Some</span>(Rc::new(ctx))).unwrap();
    <span class="macro">assert_eq!</span>(result3, <span class="number">16.0</span>); <span class="comment">// 3^2 + 2*3 + 1 = 16
</span>}</code></pre></div>
<h2 id="using-on-embedded-systems-no_std"><a class="doc-anchor" href="#using-on-embedded-systems-no_std">§</a>Using on Embedded Systems (no_std)</h2>
<p>exp-rs is designed to work in no_std environments with the alloc crate.
A C header is automatically generated at compile time using Cbindgen.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern crate </span>alloc;
<span class="kw">use </span>exp_rs::interp;
<span class="kw">use </span>exp_rs::EvalContext;
<span class="kw">use </span>exp_rs::Real;
<span class="kw">use </span>alloc::rc::Rc;

<span class="comment">// This defines an FFI function that can be called from C code
</span><span class="kw">pub extern </span><span class="string">"C" </span><span class="kw">fn </span>evaluate_expression(x: f32, y: f32) -&gt; f32 {
    <span class="comment">// Note: Real is either f32 or f64 depending on feature flags
    // Create an evaluation context
    </span><span class="kw">let </span><span class="kw-2">mut </span>ctx = EvalContext::new();

    <span class="comment">// Set parameters
    </span>ctx.set_parameter(<span class="string">"x"</span>, x <span class="kw">as </span>Real);
    ctx.set_parameter(<span class="string">"y"</span>, y <span class="kw">as </span>Real);

    <span class="comment">// Evaluate the expression
    </span><span class="kw">let </span>result = interp(<span class="string">"sqrt(x^2 + y^2)"</span>, <span class="prelude-val">Some</span>(Rc::new(ctx))).unwrap();

    <span class="comment">// Convert back to f32 for C compatibility
    </span>result <span class="kw">as </span>f32
}</code></pre></div>
<h2 id="disabling-built-in-math-functions"><a class="doc-anchor" href="#disabling-built-in-math-functions">§</a>Disabling Built-in Math Functions</h2>
<p>For embedded systems where you want to provide your own math implementations:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern crate </span>alloc;
<span class="kw">use </span>exp_rs::context::EvalContext;
<span class="kw">use </span>exp_rs::engine::interp;
<span class="kw">use </span>alloc::rc::Rc;

<span class="kw">fn </span>main() {
    <span class="kw">let </span><span class="kw-2">mut </span>ctx = EvalContext::new();

    <span class="comment">// Register custom math functions
    </span>ctx.register_native_function(<span class="string">"sin"</span>, <span class="number">1</span>, |args| args[<span class="number">0</span>].sin());
    ctx.register_native_function(<span class="string">"cos"</span>, <span class="number">1</span>, |args| args[<span class="number">0</span>].cos());
    ctx.register_native_function(<span class="string">"sqrt"</span>, <span class="number">1</span>, |args| args[<span class="number">0</span>].sqrt());

    <span class="comment">// Use the functions
    </span><span class="kw">let </span>result = interp(<span class="string">"sin(0.5) + cos(0.5)"</span>, <span class="prelude-val">Some</span>(Rc::new(ctx))).unwrap();
    <span class="macro">println!</span>(<span class="string">"Result: {}"</span>, result);
}</code></pre></div>
<h2 id="error-handling"><a class="doc-anchor" href="#error-handling">§</a>Error Handling</h2>
<p>Comprehensive error handling is provided:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern crate </span>alloc;
<span class="kw">use </span>exp_rs::context::EvalContext;
<span class="kw">use </span>exp_rs::engine::interp;
<span class="kw">use </span>exp_rs::error::ExprError;
<span class="kw">use </span>alloc::rc::Rc;

<span class="kw">fn </span>main() {
    <span class="kw">let </span>ctx = EvalContext::new();

    <span class="comment">// Handle syntax errors
    </span><span class="kw">match </span>interp(<span class="string">"2 + * 3"</span>, <span class="prelude-val">Some</span>(Rc::new(ctx.clone()))) {
        <span class="prelude-val">Ok</span>(<span class="kw">_</span>) =&gt; <span class="macro">println!</span>(<span class="string">"Unexpected success"</span>),
        <span class="prelude-val">Err</span>(ExprError::Syntax(msg)) =&gt; <span class="macro">println!</span>(<span class="string">"Syntax error: {}"</span>, msg),
        <span class="prelude-val">Err</span>(e) =&gt; <span class="macro">println!</span>(<span class="string">"Unexpected error: {:?}"</span>, e),
    }

    <span class="comment">// Handle unknown variables
    </span><span class="kw">match </span>interp(<span class="string">"x + 5"</span>, <span class="prelude-val">Some</span>(Rc::new(ctx.clone()))) {
        <span class="prelude-val">Ok</span>(<span class="kw">_</span>) =&gt; <span class="macro">println!</span>(<span class="string">"Unexpected success"</span>),
        <span class="prelude-val">Err</span>(ExprError::UnknownVariable { name }) =&gt; <span class="macro">println!</span>(<span class="string">"Unknown variable: {}"</span>, name),
        <span class="prelude-val">Err</span>(e) =&gt; <span class="macro">println!</span>(<span class="string">"Unexpected error: {:?}"</span>, e),
    }

    <span class="comment">// Handle division by zero
    </span><span class="kw">match </span>interp(<span class="string">"1 / 0"</span>, <span class="prelude-val">Some</span>(Rc::new(ctx))) {
        <span class="prelude-val">Ok</span>(result) =&gt; {
            <span class="kw">if </span>result.is_infinite() {
                <span class="macro">println!</span>(<span class="string">"Division by zero correctly returned infinity"</span>)
            } <span class="kw">else </span>{
                <span class="macro">println!</span>(<span class="string">"Unexpected result: {}"</span>, result)
            }
        },
        <span class="prelude-val">Err</span>(e) =&gt; <span class="macro">println!</span>(<span class="string">"Unexpected error: {:?}"</span>, e),
    }
}</code></pre></div>
<h2 id="attribution"><a class="doc-anchor" href="#attribution">§</a>Attribution</h2>
<p>exp-rs began as a fork of tinyexpr-rs by Krzysztof Kondrak, which itself was a port of the TinyExpr C library
by Lewis Van Winkle (codeplea). As the functionality expanded beyond the scope of the original TinyExpr,
it evolved into a new project with additional features inspired by tinyexpr-plusplus.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><dl class="item-table reexports"><dt id="reexport.BatchBuilder"><code>pub use batch_builder::<a class="struct" href="batch_builder/struct.BatchBuilder.html" title="struct exp_rs::batch_builder::BatchBuilder">BatchBuilder</a>;</code></dt><dt id="reexport.Param"><code>pub use batch_builder::<a class="struct" href="batch_builder/struct.Param.html" title="struct exp_rs::batch_builder::Param">Param</a>;</code></dt><dt id="reexport.eval_with_engine"><code>pub use eval::iterative::<a class="fn" href="eval/iterative/fn.eval_with_engine.html" title="fn exp_rs::eval::iterative::eval_with_engine">eval_with_engine</a>;</code></dt><dt id="reexport.EvalEngine"><code>pub use eval::iterative::<a class="struct" href="eval/iterative/struct.EvalEngine.html" title="struct exp_rs::eval::iterative::EvalEngine">EvalEngine</a>;</code></dt><dt><code>pub use <a class="mod" href="context/index.html" title="mod exp_rs::context">context</a>::*;</code></dt><dt><code>pub use <a class="mod" href="engine/index.html" title="mod exp_rs::engine">engine</a>::*;</code></dt><dt><code>pub use <a class="mod" href="functions/index.html" title="mod exp_rs::functions">functions</a>::*;</code></dt><dt><code>pub use <a class="mod" href="types/index.html" title="mod exp_rs::types">types</a>::*;</code></dt><dt><code>pub use <a class="mod" href="ffi/index.html" title="mod exp_rs::ffi">ffi</a>::*;</code></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="batch_builder/index.html" title="mod exp_rs::batch_builder">batch_<wbr>builder</a></dt><dd>Batch expression evaluation builder for efficient real-time evaluation</dd><dt><a class="mod" href="constants/index.html" title="mod exp_rs::constants">constants</a></dt><dt><a class="mod" href="context/index.html" title="mod exp_rs::context">context</a></dt><dt><a class="mod" href="engine/index.html" title="mod exp_rs::engine">engine</a></dt><dt><a class="mod" href="error/index.html" title="mod exp_rs::error">error</a></dt><dd>Error types and handling for the exp-rs crate.</dd><dt><a class="mod" href="eval/index.html" title="mod exp_rs::eval">eval</a></dt><dd>Expression evaluation module for exp-rs</dd><dt><a class="mod" href="expression_functions/index.html" title="mod exp_rs::expression_functions">expression_<wbr>functions</a></dt><dd>Expression functions implementation for the exp-rs library.</dd><dt><a class="mod" href="ffi/index.html" title="mod exp_rs::ffi">ffi</a></dt><dd>C FFI interface for exp-rs.</dd><dt><a class="mod" href="functions/index.html" title="mod exp_rs::functions">functions</a></dt><dd>Built-in mathematical functions for expression evaluation.</dd><dt><a class="mod" href="lexer/index.html" title="mod exp_rs::lexer">lexer</a></dt><dt><a class="mod" href="types/index.html" title="mod exp_rs::types">types</a></dt><dd>Type definitions for the expression parser and evaluator.</dd></dl><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><dl class="item-table"><dt><a class="macro" href="macro.assert_approx_eq.html" title="macro exp_rs::assert_approx_eq">assert_<wbr>approx_<wbr>eq</a></dt><dd>Utility macro to check if two floating point values are approximately equal
within a specified epsilon. Supports optional format arguments like assert_eq!.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Box.html" title="struct exp_rs::Box">Box</a></dt><dd>A pointer type that uniquely owns a heap allocation of type <code>T</code>.</dd><dt><a class="struct" href="struct.String.html" title="struct exp_rs::String">String</a></dt><dd>A UTF-8–encoded, growable string.</dd><dt><a class="struct" href="struct.Vec.html" title="struct exp_rs::Vec">Vec</a></dt><dd>A contiguous growable array type, written as <code>Vec&lt;T&gt;</code>, short for ‘vector’.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.ToString.html" title="trait exp_rs::ToString">ToString</a></dt><dd>A trait for converting a value to a <code>String</code>.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.Real.html" title="type exp_rs::Real">Real</a></dt></dl><script type="text/json" id="notable-traits-data">{"&[u8]":"<h3>Notable traits for <code>&amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>]</code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>]</div>"}</script></section></div></main></body></html>
searchState.loadedDescShard("exp_rs", 0, "exp-rs\nA pointer type that uniquely owns a heap allocation of …\nA UTF-8–encoded, growable string.\nA trait for converting a value to a <code>String</code>.\nA contiguous growable array type, written as <code>Vec&lt;T&gt;</code>, short …\nReturns a reference to the underlying allocator.\nReturns a reference to the underlying allocator.\nMoves all the elements of <code>other</code> into <code>self</code>, leaving <code>other</code> …\nReturns a byte slice of this <code>String</code>’s contents.\nReturns a raw mutable pointer to the <code>Box</code>’s contents.\nReturns a raw mutable pointer to the vector’s buffer, or …\nExtracts a mutable slice of the entire vector.\nConverts a <code>String</code> into a mutable string slice.\nReturns a mutable reference to the contents of this <code>String</code>.\nReturns a <code>NonNull</code> pointer to the vector’s buffer, or a …\nReturns a raw pointer to the <code>Box</code>’s contents.\nReturns a raw pointer to the vector’s buffer, or a …\nExtracts a slice containing the entire vector.\nExtracts a string slice containing the entire <code>String</code>.\nUtility macro to check if two floating point values are …\nConverts to <code>Box&lt;[T], A&gt;</code>.\nConverts to <code>Box&lt;T, A&gt;</code>.\nBatch expression evaluation builder for efficient …\nReturns the total number of elements the vector can hold …\nReturns this <code>String</code>’s capacity, in bytes.\nClears the vector, removing all values.\nTruncates this <code>String</code>, removing all contents.\nReturns a new box with a <code>clone()</code> of this box’s contents.\nCopies <code>source</code>’s contents into <code>self</code> without creating a …\nCopies <code>source</code>’s contents into <code>self</code> without creating a …\nOverwrites the contents of <code>self</code> with a clone of the …\nClones the contents of <code>source</code> into <code>self</code>.\nRemoves consecutive repeated elements in the vector …\nRemoves all but the first of consecutive elements in the …\nRemoves all but the first of consecutive elements in the …\nCreates a <code>Box&lt;T&gt;</code>, with the <code>Default</code> value for T.\nCreates an empty <code>Vec&lt;T&gt;</code>.\nCreates an empty <code>String</code>.\nAttempts to downcast the box to a concrete type.\nAttempts to downcast the box to a concrete type.\nAttempts to downcast the box to a concrete type.\nDowncasts the box to a concrete type.\nDowncasts the box to a concrete type.\nDowncasts the box to a concrete type.\nRemoves the subslice indicated by the given range from the …\nRemoves the specified range from the string in bulk, …\nError types and handling for the exp-rs crate.\nExpression evaluation module for exp-rs\nExpression functions implementation for the exp-rs library.\nClones and appends all elements in a slice to the <code>Vec</code>.\nGiven a range <code>src</code>, clones a slice of elements in that …\nCopies elements from <code>src</code> range to the end of the string.\nCreates an iterator which uses a closure to determine if …\nC FFI interface for exp-rs.\nConverts a <code>Cow&lt;&#39;_, [T]&gt;</code> into a <code>Box&lt;[T]&gt;</code>\nConverts a <code>Cow</code> into a box of dyn <code>Error</code>.\nConverts a <code>String</code> into a box of dyn <code>Error</code> + <code>Send</code> + <code>Sync</code>.\nConverts a type of <code>Error</code> + <code>Send</code> + <code>Sync</code> into a box of dyn …\nConverts a type of <code>Error</code> into a box of dyn <code>Error</code>.\nConverts a <code>[T; N]</code> into a <code>Box&lt;[T]&gt;</code>\nConverts a <code>Box&lt;str&gt;</code> into a <code>Box&lt;[u8]&gt;</code>\nConverts a <code>Cow&lt;&#39;_, str&gt;</code> into a <code>Box&lt;str&gt;</code>\nConverts a <code>&amp;mut str</code> into a <code>Box&lt;str&gt;</code>\nConverts a <code>Cow&lt;&#39;a, CStr&gt;</code> into a <code>Box&lt;CStr&gt;</code>, by copying the …\nConverts a <code>CString</code> into a Box&lt;CStr&gt; without copying or …\nConverts the given <code>String</code> to a boxed <code>str</code> slice that is …\nCopies the string into a newly allocated Box&lt;OsStr&gt;.\nConverts a vector into a boxed slice.\nConverts a <code>&amp;str</code> into a <code>Box&lt;str&gt;</code>\nConverts a <code>&amp;mut [T]</code> into a <code>Box&lt;[T]&gt;</code>\nConverts a <code>String</code> into a box of dyn <code>Error</code>.\nConverts a <code>T</code> into a <code>Box&lt;T&gt;</code>\nCopies the string into a newly allocated Box&lt;OsStr&gt;.\nConverts a <code>Cow&lt;&#39;a, OsStr&gt;</code> into a Box&lt;OsStr&gt;, by copying …\nConverts an <code>OsString</code> into a Box&lt;OsStr&gt; without copying or …\nCreates a boxed <code>Path</code> from a reference.\nReturns the argument unchanged.\nCreates a boxed <code>Path</code> from a reference.\nConverts a <code>str</code> into a box of dyn <code>Error</code> + <code>Send</code> + <code>Sync</code>.\nCreates a boxed <code>Path</code> from a clone-on-write pointer.\nConverts a <code>str</code> into a box of dyn <code>Error</code>.\nConverts a <code>PathBuf</code> into a Box&lt;Path&gt;.\nConverts a <code>&amp;mut CStr</code> into a <code>Box&lt;CStr&gt;</code>, by copying the …\nConverts a <code>&amp;CStr</code> into a <code>Box&lt;CStr&gt;</code>, by copying the contents …\nConverts a <code>Cow</code> into a box of dyn <code>Error</code> + <code>Send</code> + <code>Sync</code>.\nConverts a <code>&amp;[T]</code> into a <code>Box&lt;[T]&gt;</code>\nAllocates a <code>Vec&lt;T&gt;</code> and moves <code>s</code>’s items into it.\nAllocates a <code>Vec&lt;T&gt;</code> and fills it by cloning <code>s</code>’s items.\nConverts a <code>BinaryHeap&lt;T&gt;</code> into a <code>Vec&lt;T&gt;</code>.\nTurn a <code>VecDeque&lt;T&gt;</code> into a <code>Vec&lt;T&gt;</code>.\nConverts a <code>CString</code> into a Vec&lt;u8&gt;.\nAllocates a <code>Vec&lt;T&gt;</code> and fills it by cloning <code>s</code>’s items.\nReturns the argument unchanged.\nConverts the given <code>String</code> to a vector <code>Vec</code> that holds …\nAllocates a <code>Vec&lt;u8&gt;</code> and fills it with a UTF-8 string.\nAllocates a <code>Vec&lt;T&gt;</code> and fills it by cloning <code>s</code>’s items.\nConverts a boxed slice into a vector by transferring …\nConverts a clone-on-write slice into a vector.\nAllocates a <code>Vec&lt;T&gt;</code> and fills it by cloning <code>s</code>’s items.\nConverts a <code>&amp;str</code> into a <code>String</code>.\nConverts a <code>&amp;String</code> into a <code>String</code>.\nConverts the given boxed <code>str</code> slice to a <code>String</code>. It is …\nConverts a clone-on-write string to an owned instance of …\nReturns the argument unchanged.\nAllocates an owned <code>String</code> from a single character.\nConverts a <code>&amp;mut str</code> into a <code>String</code>.\nConstructs a box from a <code>NonNull</code> pointer.\nConstructs a box from a <code>NonNull</code> pointer in the given …\nCreates a <code>Vec&lt;T&gt;</code> directly from a <code>NonNull</code> pointer, a …\nCreates a <code>Vec&lt;T, A&gt;</code> directly from a <code>NonNull</code> pointer, a …\nConstructs a box from a raw pointer.\nConstructs a box from a raw pointer in the given allocator.\nCreates a <code>Vec&lt;T&gt;</code> directly from a pointer, a length, and a …\nCreates a new <code>String</code> from a pointer, a length and a …\nCreates a <code>Vec&lt;T, A&gt;</code> directly from a pointer, a length, a …\nDecode a native endian UTF-16–encoded vector <code>v</code> into a …\nDecode a native endian UTF-16–encoded slice <code>v</code> into a …\nDecode a UTF-16BE–encoded vector <code>v</code> into a <code>String</code>, …\nDecode a UTF-16BE–encoded slice <code>v</code> into a <code>String</code>, …\nDecode a UTF-16LE–encoded vector <code>v</code> into a <code>String</code>, …\nDecode a UTF-16LE–encoded slice <code>v</code> into a <code>String</code>, …\nConverts a vector of bytes to a <code>String</code>.\nConverts a slice of bytes to a string, including invalid …\nConverts a <code>Vec&lt;u8&gt;</code> to a <code>String</code>, substituting invalid UTF-8 …\nConverts a vector of bytes to a <code>String</code> without checking …\nBuilt-in mathematical functions for expression evaluation.\nInserts an element at position <code>index</code> within the vector, …\nInserts a character into this <code>String</code> at a byte position.\nInserts a string slice into this <code>String</code> at a byte position.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts the boxed slice into a boxed array.\nConverts a <code>Box&lt;T&gt;</code> into a <code>Box&lt;[T]&gt;</code>\nConverts the vector into <code>Box&lt;[T]&gt;</code>.\nConverts this <code>String</code> into a Box&lt;str&gt;.\nConverts a <code>String</code> into a byte vector.\nConverts a <code>String</code> into an iterator over the <code>char</code>s of the …\nTakes a <code>Vec&lt;[T; N]&gt;</code> and flattens it into a <code>Vec&lt;T&gt;</code>.\nConsumes the <code>Box</code>, returning the wrapped value.\nCreates a consuming iterator, that is, one that moves each …\nConsumes the <code>Box</code>, returning a wrapped <code>NonNull</code> pointer.\nConsumes the <code>Box</code>, returning a wrapped <code>NonNull</code> pointer and …\nDecomposes a <code>Vec&lt;T&gt;</code> into its raw components: …\nDecomposes a <code>Vec&lt;T&gt;</code> into its raw components: …\nConverts a <code>Box&lt;T&gt;</code> into a <code>Pin&lt;Box&lt;T&gt;&gt;</code>. If <code>T</code> does not …\nConsumes the <code>Box</code>, returning a wrapped raw pointer.\nDecomposes a <code>Vec&lt;T&gt;</code> into its raw components: …\nDecomposes a <code>String</code> into its raw components: …\nDecomposes a <code>Vec&lt;T&gt;</code> into its raw components: …\nConsumes the <code>Box</code>, returning a wrapped raw pointer and the …\nReturns <code>true</code> if the vector contains no elements.\nReturns <code>true</code> if this <code>String</code> has a length of zero, and <code>false</code>…\nConsumes and leaks the <code>Box</code>, returning a mutable reference, …\nConsumes and leaks the <code>Vec</code>, returning a mutable reference …\nConsumes and leaks the <code>String</code>, returning a mutable …\nReturns the number of elements in the vector, also …\nReturns the length of this <code>String</code>, in bytes, not <code>char</code>s or …\nAllocates memory on the heap and then places <code>x</code> into it.\nConstructs a new, empty <code>Vec&lt;T&gt;</code>.\nCreates a new empty <code>String</code>.\nAllocates memory in the given allocator then places <code>x</code> into …\nConstructs a new, empty <code>Vec&lt;T, A&gt;</code>.\nConstructs a new box with uninitialized contents.\nConstructs a new box with uninitialized contents in the …\nConstructs a new boxed slice with uninitialized contents.\nConstructs a new boxed slice with uninitialized contents …\nConstructs a new <code>Box</code> with uninitialized contents, with the …\nConstructs a new <code>Box</code> with uninitialized contents, with the …\nConstructs a new boxed slice with uninitialized contents, …\nConstructs a new boxed slice with uninitialized contents …\nConstructs a new <code>Pin&lt;Box&lt;T&gt;&gt;</code>. If <code>T</code> does not implement <code>Unpin</code>…\nConstructs a new <code>Pin&lt;Box&lt;T, A&gt;&gt;</code>. If <code>T</code> does not implement …\nRemoves the last element from a vector and returns it, or …\nRemoves the last character from the string buffer and …\nRemoves and returns the last element from a vector if the …\nAppends an element to the back of a collection.\nAppends the given <code>char</code> to the end of this <code>String</code>.\nAppends a given string slice onto the end of this <code>String</code>.\nAppends an element if there is sufficient spare capacity, …\nRemoves and returns the element at position <code>index</code> within …\nRemoves a <code>char</code> from this <code>String</code> at a byte position and …\nRemove all matches of pattern <code>pat</code> in the <code>String</code>.\nRemoves the specified range in the string, and replaces it …\nReserves capacity for at least <code>additional</code> more elements to …\nReserves capacity for at least <code>additional</code> bytes more than …\nReserves the minimum capacity for at least <code>additional</code> more …\nReserves the minimum capacity for at least <code>additional</code> …\nResizes the <code>Vec</code> in-place so that <code>len</code> is equal to <code>new_len</code>.\nResizes the <code>Vec</code> in-place so that <code>len</code> is equal to <code>new_len</code>.\nRetains only the elements specified by the predicate.\nRetains only the characters specified by the predicate.\nRetains only the elements specified by the predicate, …\nForces the length of the vector to <code>new_len</code>.\nShrinks the capacity of the vector with a lower bound.\nShrinks the capacity of this <code>String</code> with a lower bound.\nShrinks the capacity of the vector as much as possible.\nShrinks the capacity of this <code>String</code> to match its length.\nReturns the remaining spare capacity of the vector as a …\nCreates a splicing iterator that replaces the specified …\nReturns vector content as a slice of <code>T</code>, along with the …\nSplits the collection into two at the given index.\nSplits the string into two at the given byte index.\nRemoves an element from the vector and returns it.\nConverts the given value to a <code>String</code>.\nShortens the vector, keeping the first <code>len</code> elements and …\nShortens this <code>String</code> to the specified length.\nAttempts to convert a <code>Vec&lt;T&gt;</code> into a <code>Box&lt;[T; N]&gt;</code>.\nAttempts to convert a <code>Box&lt;[T]&gt;</code> into a <code>Box&lt;[T; N]&gt;</code>.\nConverts a <code>CString</code> into a <code>String</code> if it contains valid …\nConverts the given <code>Vec&lt;u8&gt;</code> into a  <code>String</code> if it contains …\nAllocates memory on the heap then places <code>x</code> into it, …\nAllocates memory in the given allocator then places <code>x</code> into …\nConstructs a new box with uninitialized contents on the …\nConstructs a new box with uninitialized contents in the …\nConstructs a new boxed slice with uninitialized contents. …\nConstructs a new boxed slice with uninitialized contents …\nConstructs a new <code>Box</code> with uninitialized contents, with the …\nConstructs a new <code>Box</code> with uninitialized contents, with the …\nConstructs a new boxed slice with uninitialized contents, …\nConstructs a new boxed slice with uninitialized contents …\nTries to reserve capacity for at least <code>additional</code> more …\nTries to reserve capacity for at least <code>additional</code> bytes …\nTries to reserve the minimum capacity for at least …\nTries to reserve the minimum capacity for at least …\nConstructs a new, empty <code>Vec&lt;T&gt;</code> with at least the specified …\nCreates a new empty <code>String</code> with at least the specified …\nConstructs a new, empty <code>Vec&lt;T, A&gt;</code> with at least the …\nType definitions for the expression parser and evaluator.\nConstructs a new, empty <code>Vec&lt;T&gt;</code> with at least the specified …\nCreates a new empty <code>String</code> with at least the specified …\nConstructs a new, empty <code>Vec&lt;T, A&gt;</code> with at least the …\nWrites the value and converts to <code>Box&lt;T, A&gt;</code>.\nArena-aware batch builder for zero-allocation expression …\nBuilder for efficient batch expression evaluation\nA parameter with its name and current value\nAdd an expression to be evaluated\nAdd an expression to be evaluated\nAdd a parameter with an initial value\nAdd a parameter with an initial value\nEvaluate all expressions with current parameter values\nEvaluate all expressions with current parameter values\nGet the number of expressions\nGet the number of expressions\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet all results as a slice\nGet all results as a slice\nGet a parameter by index\nGet a parameter by name\nGet the result of a specific expression by index\nGet the result of a specific expression by index\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new empty batch builder with arena\nCreate a new empty batch builder with arena\nGet the number of parameters\nGet the number of parameters\nUpdate a parameter value by index (fastest method)\nUpdate a parameter value by index (fastest method)\nUpdate a parameter value by name (convenient but slower)\nUpdate a parameter value by name (convenient but slower)\nEvaluation context for expressions.\nRegistry for different types of functions available in an …\nUser-defined function.\nArrays of values that can be accessed using array[index] …\nObject attributes that can be accessed using …\nConstants that cannot be modified during evaluation\nCreates a new EvalContext with default values and math …\nEnables AST caching for this context to improve …\nFunctions defined using expression strings\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRegistry of functions available in this context\nRegister a native function with the context.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nNative functions implemented in Rust code\nMulti-dimensional arrays (not yet fully supported)\nCreates a new empty evaluation context.\nOptional parent context for variable/function inheritance\nRegisters all built-in math functions as native functions …\nRegisters a function defined by an expression.\nRegisters a native function in the context.\nHelper method to set an attribute value on an object\nSets a parameter (variable) in the context.\nUnregisters an expression function from this context.\nUser-defined functions with custom behavior\nVariables that can be modified during evaluation\nCreates a new context with default math functions …\nInterprets a string as a mathematical expression, …\nParse an expression string into an AST using the Pratt …\nParse an expression with reserved variables and context …\nParse an expression with a list of reserved variable names …\nError when an array index is out of bounds.\nError when an attribute access is attempted on an object …\nError when capacity is exceeded for a heapless container.\nError when division by zero is attempted.\nError when attempting to add a parameter with a name that …\nContains the error value\nError type for expression parsing and evaluation.\nError when a function is called with the wrong number of …\nError when attempting to access a parameter by an invalid …\nContains the success value\nGeneral-purpose error for any other error conditions.\nError when parsing a floating point number.\nError when the recursion limit is exceeded during …\nResult type used throughout the crate.\nError when a string is too long for heapless string buffer.\nError during syntax analysis.\nError during lexical analysis (tokenization).\nUnknown function error\nError when a variable referenced in an expression is not …\nError for unmatched parentheses in an expression.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe attribute name that was not found\nThe base object name\nExpected number of arguments\nActual number of arguments provided\nIndex that was attempted to be accessed\nActual length of the array\nName of the function that was called\nName of the array being accessed\nContext stack management for iterative evaluation\nIterative AST evaluator\nStack-based operations for iterative AST evaluation\nManages evaluation contexts without recursion\nClear the stack while preserving capacity\nReturns the argument unchanged.\nGet a context by ID\nGet the parent ID of a context\nCalls <code>U::from(self)</code>.\nLook up a variable, checking parent contexts if needed\nCreate a new context stack\nPush a context onto the stack, returning its ID\nPush a new context with a specified parent\nReusable evaluation engine to avoid allocations\nClear parameter overrides.\nEvaluate an expression\nMain iterative evaluation function\nEvaluate an expression using a provided engine (avoids …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new evaluation engine\nCreate a new evaluation engine with arena for expression …\nSet parameter overrides for batch evaluation. These take …\nExecute a function with parameter overrides, ensuring they …\nArray access - index already evaluated\nAttribute access\nApply a function with N arguments\nApply a unary operation\nBinary operators\nCollect function arguments from the value stack\nComplete AND operation (when not short-circuited)\nApply a binary operation after both operands are evaluated\nComplete OR operation (when not short-circuited)\nPush an expression to evaluate\nOperations that can be pushed onto the evaluation stack\nVariable lookup\nShort-circuit AND operation\nShort-circuit OR operation\nHandle ternary operator - condition already evaluated\nUnary operators\nApply a unary operation to a value\nApply a binary operation to two values\nConvert from AST representation to stack operation\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if a string is a binary operator\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEvaluates an expression function with the given arguments.\nOpaque arena type for C\nOpaque type for BatchBuilder\nRequest structure for batch evaluation of multiple …\nResult structure for batch evaluation when using library …\nStatus information for individual batch evaluation results.\nOpaque handle to an evaluation context for C code.\nResult structure returned by evaluation functions.\nIndex of the batch item that produced this result (0-based)\nNumber of batch items (columns in results)\nNumber of items in each parameter array (batch size)\nError code: 0 = success, non-zero = error\nError message (valid when status is non-zero, must be …\nFrees an arena previously created by exp_rs_arena_new.\nCreates a new arena for zero-allocation expression …\nResets an arena, clearing all allocations.\nAdds an expression to the batch builder.\nAdds a parameter to the batch builder.\nEvaluates all expressions with current parameter values.\nGets the number of expressions in the batch builder.\nFrees a batch builder.\nGets the result of a specific expression by index.\nCreates a new batch builder for efficient expression …\nCreates a new batch builder with an arena for …\nGets the number of parameters in the batch builder.\nSets a parameter value by index.\nSets a parameter value by name.\nEvaluates multiple expressions with multiple parameter …\nEvaluates multiple expressions with batch allocation of …\nBatch evaluate multiple expressions with a pre-existing …\nFrees results allocated by exp_rs_batch_eval_alloc.\nEvaluates a mathematical expression using the given …\nFrees an evaluation context previously created by …\nCreates a new evaluation context.\nRegister an expression function with the given context.\nRegister a native function with the given context.\nSet a parameter value in the context.\nUnregister an expression function from the given context.\nEstimates the arena size needed for a set of expressions.\nEvaluates a mathematical expression without a context.\nFrees a string allocated by exp_rs FFI functions.\nIndex of the expression that produced this result (0-based)\nNumber of expressions (rows in results)\nNumber of expressions in the array\nArray of expression strings to evaluate\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nNumber of parameters\nArray of parameter names (shared across all evaluations)\n2D array of parameter values: param_values[param_idx][…\nAllocated 2D result array: results[expr_idx][batch_idx]\n2D array for results: results[expr_idx][batch_idx] Must …\nStatus code: 0 for success, non-zero for errors\nOverall status: 0 = success, non-zero = error\nOptional array for detailed error tracking Size should be …\nIf true, stop evaluation on first error\nThe result value (valid when status is 0)\nAdds two values.\nDivides the first value by the second.\nDummy function that panics when called.\nReturns the maximum of two values.\nReturns the minimum of two values.\nMultiplies two values.\nRaises a value to a power.\nSubtracts the second value from the first.\nThe lexer struct, which produces tokens from an input …\nA token produced by the lexer.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the original input string\nGet the remaining input from the current position\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the next token from the input.\nPeek at the next token without consuming it\nLogical AND (&amp;&amp;) - evaluates to true only if both operands …\nAn array element access.\nAn array element access.\nAbstract Syntax Tree (AST) node representing an expression.\nAn attribute access on an object.\nAn object attribute access.\nA closing delimiter like ‘)’ or ‘]’.\nA ternary conditional operation (condition ? true_expr : …\nA conditional (ternary) operation.\nA literal numerical value.\nA constant numerical value.\nEnd of the expression.\nAn error token representing invalid input.\nClassifies the kind of expression node in the AST.\nRepresents a function defined by an expression string …\nA function call with a name and list of argument …\nA function call with a specific arity (number of …\nA logical operation with short-circuit evaluation.\nA logical operation (AND/OR).\nDefines the type of logical operation.\nRepresents a native Rust function that can be registered …\nA null or placeholder token.\nA numerical literal.\nAn opening delimiter like ‘(’ or ‘[’.\nAn operator such as +, -, *, /, ^, etc.\nLogical OR (||) - evaluates to true if either operand is …\nA separator between items, typically a comma.\nClassifies the kind of token produced during lexical …\nA named variable reference.\nA variable reference.\nA variable identifier.\nNumber of arguments the function takes.\nOptional description of what the function does.\nOptional description of what the function does.\nThe original expression string defining the function body.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe actual implementation of the function as a Rust …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe name of the function as it will be used in expressions.\nThe name of the function as it will be used in expressions.\nThe parameter names that the function accepts.\nHelper method that raises a constant expression to a power.\nThe arguments passed to the function\nThe attribute name\nThe base object name\nThe condition expression to evaluate\nExpression to evaluate if condition is false (zero)\nThe expression for the index\nThe left operand (always evaluated)\nThe name of the function being called\nThe name of the array\nThe logical operator (AND or OR)\nThe right operand (conditionally evaluated based on left …\nExpression to evaluate if condition is true (non-zero)\nNumber of arguments the function takes")